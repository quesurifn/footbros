/**
 * A handler that is responsible for handling the sockets' lifecycle
 */

var timers = require('timers');
var util = require('util');
var net = require('net');

// const PORT = 2000;
// const GC_INTERVAL = 60000;
// const KEEP_ALIVE = 5000;
var PORT = 2000;
var GC_INTERVAL = 60000;
var KEEP_ALIVE = 5000;

module.exports = function(options) {
    var map = { };
    var wait = { };

    var gcInterval = (options && options.gcInterval) || GC_INTERVAL;
    var keepAlive = (options && options.keepAlive) || KEEP_ALIVE;
    var port = (options && options.port) || PORT;
    var fakeListener = function() { };

    return function(ip, callback) {
        if(!callback || typeof callback !== 'function')
            return;

        if(wait[ip]) {
            // there is yet a pending request for ip, so callback is pushed in the waiting list
            wait[ip].push(callback);
        } else if(map[ip]) {
            // there is an available handler for ip so it is returned by means of callback
            callback(null, map[ip]);
        } else {
            // there is neither a pending request nor an available handler for ip

            var socket = new net.Socket;

            wait[ip] = [callback];
            map[ip] = socket;

            var onClose = function() {
                // end or error event emitted for ip

                // Fake listener used in order to prevent
                // sporadic errors like write after FIN
                socket.on('error', fakeListener);

                socket.removeListener('error', onClose);
                socket.removeListener('close', onClose);
                socket.removeListener('end', onClose);

                delete wait[ip];
                delete map[ip];
            };

            var onGc = function() {
                // the garbage collector has been started for ip

                onClose();
                socket.end();
                timers.setTimeout(socket.destroy.bind(socket), gcInterval);
            };

            var onConnectError = function() {
                // something has gone wrong while connecting to ip

                var callbacks = wait[ip];

                delete wait[ip];
                delete map[ip];

                socket.removeListener('connect', onConnect);

                callbacks.forEach(function(fn) {
                    // error for ip returned by means of callback
                    fn(new Error);
                });
            };

            var onConnect = function() {
                // an handler for ip has been correctly created

                var callbacks = wait[ip];

                delete wait[ip];

                socket.removeListener('error', onConnectError);

                socket.setTimeout(gcInterval, onGc);
                socket.setKeepAlive(true, keepAlive);
                socket.setNoDelay(true);

                socket.once('error', onClose);
                socket.once('close', onClose);
                socket.once('end', onClose);

                callbacks.forEach(function(fn) {
                    // handler for ip returned by means of callback
                    fn(null, map[ip]);
                });
            };

            socket.connect(port, ip, onConnect);
            socket.once('error', onConnectError);
        }
    };
};

