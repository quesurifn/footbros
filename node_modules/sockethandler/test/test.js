var options = { 'port': 2000, 'gcInterval': 500, 'keepAlive': 500 };
var host = [ '127.0.0.1', 'localhost' ];

var handler = require('../index.js')(options);
var timers = require('timers');
var net = require('net');

describe('Socket Hanlder', function() {
    var msg = new Buffer([42]);

    describe('Connections', function() {
        describe('Connection available', function() {
            var server;

            before(function(done) {
                server = net.createServer(function(conn) {
                    conn.end();
                }).listen(2000, done);
            });

            it('should return the same socket twice', function(done) {
                var s1 = null;
                var s2 = null;

                handler(host[0], function(err, socket) {
                    if(err) throw new Error;
                    s1 = socket;
                    if(s2) {
                        if(s1 === s2) done();
                        else throw new Error;
                    }
                });

                handler(host[0], function(err, socket) {
                    if(err) throw new Error;
                    s2 = socket;
                    if(s1) {
                        if(s1 === s2) done();
                        else throw new Error;
                    }
                });
            });

            it('should return two different sockets', function(done) {
                var s1 = null;
                var s2 = null;

                handler(host[0], function(err, socket) {
                    if(err) throw new Error;
                    s1 = socket;
                    if(s2) {
                        if(s1 !== s2) done();
                        else throw new Error;
                    }
                });

                handler(host[1], function(err, socket) {
                    if(err) throw new Error;
                    s2 = socket;
                    if(s1) {
                        if(s1 !== s2) done();
                        else throw new Error;
                    }
                });
            });

            after(function(done) {
                server.close(done);
            });
        });

        describe('Connection unavailable', function() {
            it('should return a connection error (single request)', function(done) {
                handler(host[0], function(err, socket) {
                    if(err) done();
                    else throw new Error;
                });
            });

            it('should return a connection error (multiple requests)', function(done) {
                var cnt = 0;

                handler(host[0], function(err, socket) {
                    if(!err) throw new Error;
                    else if(++cnt === 3) done();
                });

                handler(host[0], function(err, socket) {
                    if(!err) throw new Error;
                    else if(++cnt === 3) done();
                });

                handler(host[0], function(err, socket) {
                    if(!err) throw new Error;
                    else if(++cnt === 3) done();
                });
            });
        });
    });

    describe('Write', function() {
        var server;

        before(function(done) {
            server = net.createServer(function(conn) {
                conn.pipe(conn);
            }).listen(2000, done);
        });

        it('should be possible to write buffers through the socket', function(done) {
            handler(host[0], function(err, socket) {
                if(err) throw new Error;

                socket.on('data', function(data) {
                    if(msg.toString('hex') === data.toString('hex')) done();
                    else throw new Error;
                });

                socket.write(msg);
                socket.end();
            });
        });

        it('should be possible to write strings through the socket', function(done) {
            handler(host[1], function(err, socket) {
                if(err) throw new Error;

                socket.on('data', function(data) {
                    if(msg.toString('hex') === data.toString('hex')) done();
                    else throw new Error;
                });

                socket.write(msg.toString('hex'), 'hex');
                socket.end();
            });
        });

        after(function(done) {
            server.close(done);
        });
    });

    describe('GC', function() {
        var server;

        before(function(done) {
            server = net.createServer(function(conn) {
                conn.pipe(conn);
            }).listen(2000, done);
        });

        it('should detach itself after 500 milliseconds', function(done) {
            this.timeout(2500);

            var now = Date.now();
            handler(host[0], function(err, socket) {
                if(err) throw new Error;
                socket.on('end', function() {
                    var interval = Date.now() - now;
                    if(interval >= 500) done();
                    else throw new Error;
                });
           });
        });

        it('should detach itself after 750 milliseconds', function(done) {
            this.timeout(2500);

            var now = Date.now();
            handler(host[1], function(err, socket) {
                if(err) throw new Error;

                timers.setTimeout(function() { socket.write(msg); }, 250);

                socket.on('data', function() { });

                socket.on('end', function() {
                    var interval = Date.now() - now;
                    if(interval >= 750) done();
                    else throw new Error;
                });
           });
        });

        it('should detach itself after 1000 milliseconds', function(done) {
            this.timeout(2500);

            var now = Date.now();
            handler(host[1], function(err, socket) {
                if(err) throw new Error;

                timers.setTimeout(function() { socket.write(msg); }, 250);
                timers.setTimeout(function() { socket.write(msg); }, 500);

                socket.on('data', function() { });

                socket.on('end', function() {
                    var interval = Date.now() - now;
                    if(interval >= 1000) done();
                    else throw new Error;
                });
           });
        });

        after(function(done) {
            server.close(done);
        });
    });
});
